# CFG - A CFG Parser in Zig
> Just refreshing my memory of CFGs and the use of Bison and Flex for parsing

This is a Context Free Grammar (CFG) parser generated by Bison, then used from within a Zig program.

## What makes this grammar "Context Free"?

A grammar is "context free" when each production rule can be applied regardless of
the context in which its non-terminal appears. In other words, the way we can expand
a non-terminal symbol depends only on the non-terminal itself, not on any surrounding symbols.

For example, in our grammar:
- When we see 'expr', we can always expand it to either a 'term' or an 'expr' followed by '+'/'-' and a 'term'
- When we see 'term', we can always expand it to either a 'factor' or a 'term' followed by '*'/'/' and a 'factor'
- This is true regardless of where these non-terminals appear in the input

This is in contrast to context-sensitive grammars where the application of rules might
depend on surrounding symbols. For example, a context-sensitive grammar might require
that a variable must be declared before it's used - the interpretation of a symbol
would depend on what came before it.

## Operator Precedence in the Grammar

The grammar enforces operator precedence through its structure. Notice how multiplication
and division bind "harder" (have higher precedence) than addition and subtraction:

```
expr   : term              # An expression is first broken into terms
       | expr "+" term     # Terms can be added/subtracted
       | expr "-" term

term   : factor           # A term is first broken into factors
       | term "*" factor  # Factors can be multiplied/divided
       | term "/" factor

factor : NUMBER
       | "(" expr ")"
```

The key insight is the hierarchical relationship:
- An 'expr' is made up of 'term's connected by +/-
- A 'term' is made up of 'factor's connected by *//
- This naturally makes */รท bind harder than +/-

For example, in "3 + 4 * 2":
1. 4 * 2 must be evaluated at the 'term' level first
2. Only then can the result be used in the 'expr' level for addition

This is why we don't need to write explicit precedence rules - it's built into the structure of the grammar itself.

## The Grammar in EBNF

The same grammar in EBNF notation:

```
Expr   -> Term (("+" | "-") Term)*
Term   -> Factor (("*" | "/") Factor)*
Factor -> "(" Expr ")" | Number
Number -> [0-9]+
```

## Run the code

```
$ make

$ ./main
Expression: 3 + (4 * 2)
Result: 11
